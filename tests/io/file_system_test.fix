module FileSystemTest;

import AsyncTask;

import Minilib.Common.IOEx;
import Minilib.Common.TimeEx;
import Minilib.IO.FileSystem;
import Minilib.Monad.Error;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Trait.Traversable;

test_fdopen: TestCase;
test_fdopen = (
    let testname = "test_fdopen";
    make_test(testname) $ |_|
    let path = "/tmp/_test_fdopen.tmp";
    let fd = *creat(path, /* 0o0644 = */ 420_U32);
    let fh = *fdopen(fd, "w");
    write_string(fh, "test");;
    fflush(fh);;
    close_file(fh).lift;;
    let str = *read_file_string(path);
    unlink(path);;
    assert_equal("eq", "test", str);;
    pure()
);

test_open_pipe: TestCase;
test_open_pipe = (
    let testname = "test_open_pipe";
    make_test(testname) $ |_|

    let max_count = 10;
    let (read_fh, write_fh) = *open_pipe;
    let reader: IOFail String = loop_m(
        Array::empty(max_count), |array|
        let line = *read_line(read_fh);
        if line == "" {
            close_file(read_fh).lift;;
            break_m $ array.to_iter.join(",")
        };
        //println(line.strip_last_newlines).lift;;
        let array = array.push_back(line.strip_last_newlines);
        continue_m $ array
    );
    let reader: IO String = reader.try(|err|
        eprintln("reader: "+ err);;
        pure ("")
    );

    let writer: IOFail () = loop_m(
        0, |i|
        if i > max_count {
            close_file(write_fh).lift;;
            break_m $ ()
        };
        write_string(write_fh, i.to_string + "\n");;
        fflush(write_fh);;
        usleep(1000_U32);; // 1000 usec = 1 msec
        continue_m $ i + 1
    );
    let writer: IO () = writer.try(|err|
        eprintln("writer: "+ err)
    );

    let read_task = *AsyncIOTask::make(reader).lift;
    let write_task = *AsyncIOTask::make(writer).lift;
    write_task.get.lift;;
    let str = *read_task.get.lift;
    //println("str="+str).lift;;
    assert_equal("eq", "0,1,2,3,4,5,6,7,8,9,10", str);;
    pure()
);

test_list_dir: TestCase;
test_list_dir = (
    let testname = "test_list_dir";
    make_test(testname) $ |_|
    let names = *list_dir("tests/io");
    let contains = |name, names| (
        names.find_by(|n| n == name).is_some
    );
    //println(names.to_string).lift;;
    assert_true("contains file_system_test.fix", names.contains("file_system_test.fix"));;
    assert_true("not contains `.`", !names.contains("."));;
    assert_true("not contains `..`", !names.contains(".."));;
    pure()
);

test_file_directory_exists: TestCase;
test_file_directory_exists = (
    let testname = "test_file_directory_exists";
    make_test(testname) $ |_|

    let dir_path = "tests/io";
    let file_path = "tests/io/file_system_test.fix";
    let dir_path_not_exist = dir_path + "_not_exist";
    let file_path_not_exist = file_path + "_not_exist";

    let test: String -> Bool -> Bool -> IOFail () = (
        |path, expect_dir_ex, expect_file_ex|
        let dir_ex = *directory_exists(path).lift;
        let file_ex = *file_exists(path).lift;
        assert_equal("dir_ex:" + path, expect_dir_ex, dir_ex);;
        assert_equal("file_ex:" + path, expect_file_ex, file_ex);;
        pure ()
    );

    test(file_path, false, true);;
    test(file_path_not_exist, false, false);;
    test(dir_path, true, false);;
    test(dir_path_not_exist, false, false);;
    pure()
);

test_file_stat: TestCase;
test_file_stat = (
    let testname = "test_file_stat";
    make_test(testname) $ |_|

    let file_path = "tests/io/file_system_test.fix";
    let file_stat = *stat(file_path);
    println("st_dev=" + file_stat.st_dev.to_string).lift;;
    println("st_ino=" + file_stat.st_ino.to_string).lift;;
    println("st_nlink=" + file_stat.st_nlink.to_string).lift;;
    println("st_mode=" + file_stat.st_mode.to_string).lift;;
    println("st_uid=" + file_stat.st_uid.to_string).lift;;
    println("st_gid=" + file_stat.st_gid.to_string).lift;;
    println("st_rdev=" + file_stat.st_rdev.to_string).lift;;
    println("st_size=" + file_stat.st_size.to_string).lift;;
    println("st_blksize=" + file_stat.st_blksize.to_string).lift;;
    println("st_blocks=" + file_stat.st_blocks.to_string).lift;;
    println("st_atime=" + file_stat.st_atime.to_string).lift;;
    println("st_mtime=" + file_stat.st_mtime.to_string).lift;;
    println("st_ctime=" + file_stat.st_ctime.to_string).lift;;
    assert_true("file_stat.is_file", file_stat.is_file);;
    assert_true("!file_stat.is_dir", !file_stat.is_dir);;

    let dir_path = "tests/io";
    let dir_stat = *stat(dir_path);
    assert_true("!dir_stat.is_file", !dir_stat.is_file);;
    assert_true("dir_stat.is_dir", dir_stat.is_dir);;
    pure()
);

test_find_files: TestCase;
test_find_files = (
    let testname = "test_file_stat";
    make_test(testname) $ |_|

    let dir_path = "tests";
    let file_paths = *find_files(dir_path);

    file_paths.to_iter.foreach_m(
        |file_path|
        let actual = *file_exists(file_path).lift;
        assert_equal("file exists", true, actual);;
        pure()  // println(file_path).lift
    );;
    // TODO: check file_paths are correct
    pure()
);

test_make_dirs_rmdir: TestCase;
test_make_dirs_rmdir = (
    let testname = "test_make_dirs_rmdir";
    make_test(testname) $ |_|

    let dir_path1 = ".tmp/file_system_test";
    let dir_path2 = ".tmp/file_system_test/test_make_dirs_rmdir";
    make_dirs(dir_path2, none());;
    let actual = *directory_exists(dir_path2).lift;
    assert_equal("dir exists", true, actual);;
    rmdir(dir_path2);;
    let actual = *directory_exists(dir_path2).lift;
    assert_equal("dir exists", false, actual);;
    rmdir(dir_path1);;
    let actual = *directory_exists(dir_path1).lift;
    assert_equal("dir exists", false, actual);;
    pure()
);

test_mkdir_rmdir: TestCase;
test_mkdir_rmdir = (
    let testname = "test_mkdir_rmdir";
    make_test(testname) $ |_|
    let tmp_dir = "tmp.test_mkdir_rmdir.tmp";
    let tmp_dir_exists = directory_exists(tmp_dir).lift;
    when(*tmp_dir_exists, rmdir(tmp_dir));;
    mkdir(tmp_dir, some(0o755_U32));;
    assert_true("mkdir", *tmp_dir_exists);;
    rmdir(tmp_dir);;
    assert_true("rmdir", !*tmp_dir_exists);;
    pure()
);

test_getcwd_chdir: TestCase;
test_getcwd_chdir = (
    let testname = "test_getcwd_chdir";
    make_test(testname) $ |_|

    let initial_wd = *getcwd;
    println("initial_wd=" + initial_wd).lift;;
    assert_true("initial_wd", initial_wd.ends_with("fixlang-minilib-io"));;

    let tmp_dir = "tmp.test_getcwd_chdir.tmp";
    let tmp_dir_exists = directory_exists(tmp_dir).lift;
    when(*tmp_dir_exists, rmdir(tmp_dir));;
    mkdir(tmp_dir, some(0o755_U32));;
    assert_true("mkdir", *tmp_dir_exists);;

    let res = *do {
        chdir(tmp_dir);;
        let current_wd = *getcwd;
        println("current_wd=" + current_wd).lift;;
        assert_true("current_wd", current_wd.ends_with(tmp_dir))
    }.to_result.lift;

    chdir(initial_wd).try(eprintln).lift;;
    when(*tmp_dir_exists, rmdir(tmp_dir));;
    res.from_result
);

test_realpath: TestCase;
test_realpath = (
    let testname = "test_realpath";
    make_test(testname) $ |_|
    let dir = *Iterator::range(0,20).loop_iter_m(
        ".", |i, dir|
        let resolved = *realpath(dir);
        println((i, dir, resolved).format("{}: {} = {}")).lift;;
        assert_true("resolved path starts with '/'", resolved.starts_with("/"));;
        if resolved == "/" { break_m $ dir };
        continue_m $ dir + "/.."
    );
    pure()
);

test_creat_unlink: TestCase;
test_creat_unlink = (
    let testname = "test_creat_unlink";
    make_test(testname) $ |_|
    let tmp_file = "tmp.test_creat_unlink.tmp";
    let tmp_file_exists = file_exists(tmp_file).lift;
    when(*tmp_file_exists, unlink(tmp_file));;
    creat(tmp_file, 0o644_U32);;
    assert_true("creat", *tmp_file_exists);;
    unlink(tmp_file);;
    assert_true("unlink", !*tmp_file_exists);;
    pure()
);

test_pipe: TestCase;
test_pipe = (
    let testname = "test_pipe";
    make_test(testname) $ |_|
    let (read_fd, write_fd) = *pipe;
    let n = 16;
    let input = Array::fill(n, 0_U8);
    let output = Array::from_map(n, |i| i.to_U8);
    let wsize = *output.borrow_boxed_io(|p_output|
        FFI_CALL_IO[CSizeT write(CInt, Ptr, CSizeT), write_fd.to_CInt, p_output, n.to_CSizeT]
    ).lift;
    let (input, rsize) = *input.mutate_boxed_io(|p_input|
        FFI_CALL_IO[CSizeT read(CInt, Ptr, CSizeT), read_fd.to_CInt, p_input, n.to_CSizeT]
    ).lift;
    FFI_CALL_IO[() close(CInt), write_fd.to_CInt].lift;;
    FFI_CALL_IO[() close(CInt), read_fd.to_CInt].lift;;
    assert_equal("write", n.to_CSizeT, wsize);;
    assert_equal("read", n.to_CSizeT, rsize);;
    assert_equal("input", output, input);;
    pure()
);

test_open_temp_file: TestCase;
test_open_temp_file = (
    make_table_test("test_open_temp_file",
        do {
            let prefix = *["temp123", "nosuchdir/temp123", "/tmp/temp123"];
            let auto_unlink = *[true, false];
            let expected = if prefix.starts_with("nosuchdir/") { err("err") } else { ok() };
            pure $ (prefix, auto_unlink, expected)
        },
        |(prefix, auto_unlink, expected)|
        let res = *open_temp_file(prefix, auto_unlink).to_result.lift;
        if expected.is_err {
            assert_true("open_temp_file should fail", res.is_err);;
            assert_true("errmsg contains \"mkstemp\"", res.as_err.find("mkstemp",0).is_some)
        };
        let (filepath, handle) = res.as_ok;
        do {
            assert_true("filepath starts with prefix", filepath.starts_with(prefix));;
            assert_equal("filepath.@size = prefix.@size + 6", filepath.@size, prefix.@size + 6);;
            if auto_unlink {
                assert_true("filepath not exists", ! *file_exists(filepath))
            } else {
                assert_true("filepath exists", *file_exists(filepath))
            };;
            pure()
        }
        .finally(
            close_file(handle).lift;;
            unlink(filepath).unless(auto_unlink)
        )
    )
);

test_with_temp_file: TestCase;
test_with_temp_file = (
    make_table_test("test_with_temp_file",
        do {
            let prefix = *["temp123", "nosuchdir/temp123", "/tmp/temp123"];
            let auto_unlink = *[true, false];
            let expected = if prefix.starts_with("nosuchdir/") { err("err") } else { ok() };
            pure $ (prefix, auto_unlink, expected)
        },
        |(prefix, auto_unlink, expected)| 
        let body = |(filepath, handle)| (
            assert_true("filepath starts with prefix", filepath.starts_with(prefix));;
            assert_equal("filepath.@size = prefix.@size + 6", filepath.@size, prefix.@size + 6);;
            if auto_unlink {
                assert_true("filepath not exists", ! *file_exists(filepath))
            } else {
                assert_true("filepath exists", *file_exists(filepath))
            };;
            // returns filepath and handle for checking whether the cleanup is performed correctly
            pure $ (filepath, handle)
        );
        let res = *with_temp_file(prefix, auto_unlink, body).to_result.lift;
        if expected.is_err {
            assert_true("open_temp_file should fail", res.is_err);;
            assert_true("errmsg contains \"mkstemp\"", res.as_err.find("mkstemp",0).is_some)
        };
        // check cleanup
        let (filepath, handle) = *res.from_result;
        assert_true("filepath not exists after cleanup", ! *file_exists(filepath));;
        assert_equal("filehandle is closed after cleanup", nullptr, *handle.get_file_ptr.lift)
    )
);

test_seek_tell_file: TestCase;
test_seek_tell_file = (
    make_test("test_seek_tell_file") $ |_|
    with_temp_file("test_seek_tell_file", true) $ |(filepath, handle)|
    let offset = *get_file_position(handle);
    assert_equal("start", 0.to_CLong, offset);;
    write_string(handle, "abcdef\n");;
    flush(handle).lift;;
    let offset = *get_file_position(handle);
    assert_equal("after writing a line", 7.to_CLong, offset);;
    set_file_position(handle, -2.to_CLong, seek_cur());;
    set_file_position(handle, -3.to_CLong, seek_cur());;
    let offset = *get_file_position(handle);
    assert_equal("after seek with seek_cur", 2.to_CLong, offset);;
    set_file_position(handle, -1.to_CLong, seek_end());;
    let offset = *get_file_position(handle);
    assert_equal("after seek with seek_end", 6.to_CLong, offset);;
    set_file_position(handle, 1.to_CLong, seek_set());;
    let offset = *get_file_position(handle);
    assert_equal("after seek with seek_set", 1.to_CLong, offset);;
    let line = *read_line(handle);
    assert_equal("line", "bcdef\n", line);;
    let offset = *get_file_position(handle);
    assert_equal("after read line", 7.to_CLong, offset);;
    pure()
);

main: IO ();
main = (
    [
        test_fdopen,
        test_open_pipe,
        test_list_dir,
        test_file_directory_exists,
        test_file_stat,
        test_find_files,
        test_make_dirs_rmdir,
        test_realpath,
        test_creat_unlink,
        test_mkdir_rmdir,
        test_getcwd_chdir,
        test_pipe,
        test_open_temp_file,
        test_with_temp_file,
        test_seek_tell_file,
        TestCase::empty
    ]
    .run_test_driver
);

