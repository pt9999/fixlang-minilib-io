// File system module. For example, finding files, checks if file or directory exists,
// getting file size and last modified time.
module Minilib.IO.FileSystem;

import Time;

import Minilib.Encoding.Binary;
import Minilib.IO.Errno;
import Minilib.IO.Platform;
import Minilib.IO.Path;
import Minilib.Monad.IO;
import Minilib.Monad.Error;
import Minilib.Text.StringEx;

//--------------------------------------------------------------------------
//  File status
//--------------------------------------------------------------------------

// Returns true if the specified file exists.
//
// NOTE: If `file_path` is a broken symbolic link, it returns false.
//
// # Parameters
// - `file_path`: a file path
file_exists: [m: MonadIO] String -> m Bool;
file_exists = |file_path| lift_io $ do {
    pure();;    // make it lazy
    let res = *stat(file_path).to_result;
    if res.is_err {
        pure $ false
    };
    let file_stat = res.as_ok;
    pure $ file_stat.is_file
};

// Returns true if the specified directory exists.
//
// NOTE: If `file_path` is a broken symbolic link, it returns false.
//
// # Parameters
// - `dir_path`: a directory path
directory_exists: [m: MonadIO] String -> m Bool;
directory_exists = |dir_path| lift_io $ do {
    pure();;    // make it lazy
    let res = *stat(dir_path).to_result;
    if res.is_err {
        pure $ false
    };
    let file_stat = res.as_ok;
    pure $ file_stat.is_dir
};

// Type of file status
type FileStat = unbox struct {
    data: Array U64
};

namespace FileStat {
    // `stat(file_path)` retrieves information about the file pointed to by `file_path`.
    //
    // For detials, see Linux manual page for [stat(2)](https://man7.org/linux/man-pages/man2/stat.2.html)
    // and [stat(3type)](https://man7.org/linux/man-pages/man3/stat.3type.html).
    //
    // # Parameters
    // - `file_path`: a file path
    stat: [m: MonadIOFail] String -> m FileStat;
    stat = |file_path| _stat_or_lstat(file_path, true);

    // `lstat(file_path)` retrieves information about the file pointed to by `file_path`.
    // If `file_path` is a symbolic link, it retrieves information about the symbolic link itself, 
    // not the file it references.
    //
    // For detials, see Linux manual page for [lstat(2)](https://man7.org/linux/man-pages/man2/lstat.2.html)
    // and [stat(3type)](https://man7.org/linux/man-pages/man3/stat.3type.html).
    //
    // # Parameters
    // - `file_path`: a file path
    lstat: [m: MonadIOFail] String -> m FileStat;
    lstat = |file_path| _stat_or_lstat(file_path, false);

    // internal function of `stat` and `lstat`
    _stat_or_lstat: [m: MonadIOFail] String -> Bool -> m FileStat;
    _stat_or_lstat = |file_path, is_stat| lift_iofail $ do {
        pure();; // make it lazy
        clear_errno.lift;;
        let data = Array::fill(16, 0_U64);
        let (data, res) = *data.mutate_boxed_io(|p_data|
            file_path.borrow_c_str_io(|p_filepath|
                FFI_CALL_IO[CInt minilib_iofs_stat_or_lstat(Ptr, Ptr, CInt), p_filepath, p_data, 
                    if is_stat { 1.to_CInt } else { 0.to_CInt }
                ]
            )
        ).lift;
        if res != 0.to_CInt {
            let func_name = if is_stat { "stat" } else { "lstat" };
            throw(func_name + "(\"" + file_path + "\") failed!: " + *get_last_error.lift)
        };
        pure $ FileStat { data: data }
    };

    // Returns true if it is a regular file.
    //
    // # Parameters
    // - `file_stat`: a file status obtained by `stat`
    is_file: FileStat -> Bool;
    is_file = |file_stat| (
        FFI_CALL[CInt minilib_iofs_stat_mode_is_file(U32), file_stat.st_mode]
        != 0.to_CInt
    );

    // Returns true if it is a symbolic link.
    //
    // # Parameters
    // - `file_stat`: a file status obtained by `lstat`
    is_symbolic_link: FileStat -> Bool;
    is_symbolic_link = |file_stat| (
        FFI_CALL[CInt minilib_iofs_stat_mode_is_symbolic_link(U32), file_stat.st_mode]
        != 0.to_CInt
    );

    // Returns true if it is a directory.
    //
    // # Parameters
    // - `file_stat`: a file status obtained by `stat`
    is_dir: FileStat -> Bool;
    is_dir = |file_stat| (
        FFI_CALL[CInt minilib_iofs_stat_mode_is_dir(U32), file_stat.st_mode]
        != 0.to_CInt
    );

    st_dev: FileStat -> U64;
    st_dev = |file_stat| file_stat.@data.@(0);

    st_ino: FileStat -> U64;
    st_ino = |file_stat| file_stat.@data.@(1);

    st_nlink: FileStat -> U64;
    st_nlink = |file_stat| file_stat.@data.@(2);

    st_mode: FileStat -> U32;
    st_mode = |file_stat| file_stat.@data.@(3).to_U32;

    st_uid: FileStat -> U32;
    st_uid = |file_stat| file_stat.@data.@(4).to_U32;

    st_gid: FileStat -> U32;
    st_gid = |file_stat| file_stat.@data.@(5).to_U32;

    st_rdev: FileStat -> U64;
    st_rdev = |file_stat| file_stat.@data.@(6);

    st_size: FileStat -> I64;
    st_size = |file_stat| file_stat.@data.@(7).to_I64;

    st_blksize: FileStat -> I64;
    st_blksize = |file_stat| file_stat.@data.@(8).to_I64;

    st_blocks: FileStat -> U64;
    st_blocks = |file_stat| file_stat.@data.@(9);

    st_atim: FileStat -> Time;
    st_atim = |file_stat| Time {
        sec: file_stat.@data.@(10).to_I64,
        nanosec: file_stat.@data.@(11).to_U32,
    };

    st_mtim: FileStat -> Time;
    st_mtim = |file_stat| Time {
        sec: file_stat.@data.@(12).to_I64,
        nanosec: file_stat.@data.@(13).to_U32,
    };

    st_ctim: FileStat -> Time;
    st_ctim = |file_stat| Time {
        sec: file_stat.@data.@(14).to_I64,
        nanosec: file_stat.@data.@(15).to_U32,
    };

    st_atime: FileStat -> U64;
    st_atime = |file_stat| file_stat.@data.@(10);

    st_mtime: FileStat -> U64;
    st_mtime = |file_stat| file_stat.@data.@(12);

    st_ctime: FileStat -> U64;
    st_ctime = |file_stat| file_stat.@data.@(14);
}

//--------------------------------------------------------------------------
//  Finding files
//--------------------------------------------------------------------------

// `find_files(dir_path)` finds all files under
// specified directory and its subdirectories.
//
// Example:
// ```
// find_files("./lib")
// ==> ["./lib/io/errno.fix","./lib/io/file_system.fix","./lib/io/path.fix","./lib/io/platform.fix","./lib/io/signal.fix"]
// ```
//
// # Parameters
// - `dir_path`: a directory path
find_files: [m: MonadIOFail] String -> m (Array String);
find_files = |dir_path| lift_iofail $ do {
    pure();;    // make it lazy
    let dir_path = if dir_path.ends_with("/") { dir_path } else { dir_path + "/" };
    let output = Array::empty(10);
    let files = *list_dir(dir_path);
    files.to_iter.loop_iter_m(
        output, |file, output|
        let file_path = dir_path + file;
        if *directory_exists(file_path).lift {
            let output = output.append(*find_files(file_path));
            continue_m $ output
        };
        if *file_exists(file_path).lift {
            let output = output.push_back(file_path);
            continue_m $ output
        };
        continue_m $ output
    )
};

// Lists a directory.
// Returns filenames in the specified directory.
// The filenames will be sorted in lexicographical order.
//
// # Parameters
// - `dir_path`: a directory path
list_dir: [m: MonadIOFail] String -> m (Array String);
list_dir = |dir_path| lift_iofail $ do {
    pure();;    // make it lazy
    let dir_handle = *_opendir(dir_path);
    let names: Array String = Array::empty(10);
    let names = *loop_m(
        names, |names|
        let name = *_readdir(dir_handle);
        if name == "" {
            break_m $ names
        };
        if name == "." || name == ".." {
            continue_m $ names
        };
        let names = names.push_back(name);
        continue_m $ names
    );
    let names = names.sort_by(|(a,b)| a < b);
    pure $ names
};

// Type of a directory handle (used internally)
type DirHandle = unbox struct {
    dtor: Destructor Ptr
};

_opendir: [m: MonadIOFail] String -> m DirHandle;
_opendir = |dir_path| lift_iofail $ do {
    clear_errno.lift;;
    let dirp = *dir_path.borrow_c_str_io(|p_path|
        FFI_CALL_IO[Ptr opendir(Ptr), p_path]
    ).lift;
    if dirp == nullptr {
        throw("opendir(\"" + dir_path + "\") failed!: " + *get_last_error.lift)
    };
    pure $ DirHandle {
        dtor: *Destructor::make(dirp, |dirp|
            //eval debug_eprintln ("closing dir handle");
            //eval clear_errno._unsafe_perform;
            let res = *FFI_CALL_IO[CInt closedir(Ptr), dirp];
            /*eval if res != 0.to_CInt {
                debug_eprintln("closedir failed!: res=" + res.to_string)
            } else {
                ()
            };
            */
            pure $ nullptr
        ).lift
    }
};

_readdir: [m: MonadIOFail] DirHandle -> m String;
_readdir = |dir_handle| lift_iofail $ do {
    clear_errno.lift;;
    let bufsize = 256;
    let buf = Array::fill(bufsize, 0_U8);
    let (buf, len) = *dir_handle.@dtor.borrow_io(|dirp|
        buf.mutate_boxed_io(|p_buf|
            FFI_CALL_IO[CSizeT minilib_iofs_readdir(Ptr, Ptr, CSizeT), dirp, p_buf, bufsize.to_CSizeT]
        )
    ).lift;
    if len.to_I64 == 0 {
        let errno = *get_errno.lift;
        if errno != 0.to_CInt {
            throw("readdir failed!: " + *get_last_error.lift)
        };
        pure $ ""
    };
    let buf = buf.get_sub(0, len.to_I64);
    pure $ buf._unsafe_to_string
};

//--------------------------------------------------------------------------
//  Directory
//--------------------------------------------------------------------------

// `make_dirs(dir_path, mode)` creates specified directory
// as well as its parent directories recursively.
// If the directory already exists, it does nothing.
// If `mode` is `none()`, octal 0777 is used as a mode.
// This mode is modified by the process's umask in the usual way.
//
// # Parameters
// - `dir_path`: the directory path to be created
// - `mode`: `some()` of a file mode of the created directories, or `none()`
make_dirs: [m: MonadIOFail] String -> Option U32 -> m ();
make_dirs = |dir_path, mode| lift_iofail $ do {
    pure();;    // make it lazy
    if *directory_exists(dir_path).lift {
        pure()
    };
    let parent_dir = dirname(dir_path);
    if parent_dir == dir_path {
        pure()  // avoid infinite loop
    } else {
        make_dirs(parent_dir, mode)
    };;
    mkdir(dir_path, mode)
};

// `mkdir(dir_path, mode)` creates a directory.
// If `mode` is `none()`, octal 0777 is used as a mode.
// This mode is modified by the process's umask in the usual way.
//
// # Parameters
// - `dir_path`: the directory path to be created
// - `mode`: `some()` of a file mode of the created directory, or `none()`
mkdir: [m: MonadIOFail] String -> Option U32 -> m ();
mkdir = |path, mode| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let mode = if mode.is_some { mode.as_some } else { /* 0777 = */ 511_U32 };
    let res = *path.borrow_c_str_io(|p_path|
        FFI_CALL_IO[CInt mkdir(Ptr, U32), p_path, mode]
    ).lift;
    if res != 0.to_CInt {
        throw("mkdir(\"" + path + "\"," + mode.to_string + ") failed!: " + *get_last_error.lift)
    };
    pure()
};

// `rmdir(path)` deletes a directory, which must be empty.
//
// # Parameters
// - `dir_path`: the directory path to be deleted
rmdir: [m: MonadIOFail] String -> m ();
rmdir = |path| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let res = *path.borrow_c_str_io(|p_path|
        FFI_CALL_IO[CInt rmdir(Ptr), p_path]
    ).lift;
    if res != 0.to_CInt {
        throw("rmdir(\"" + path + "\") failed!: " + *get_last_error.lift)
    };
    pure()
};

// `getcwd` returns an absolute pathname of the current working directory.
getcwd: [m: MonadIOFail] m String;
getcwd = lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let bufsize = 1024;     // TODO: use PATH_MAX or pathconf
    let buf = Array::fill(bufsize, 0_U8);
    let (buf, res) = *buf.mutate_boxed_io(|p_buf|
        FFI_CALL_IO[Ptr getcwd(Ptr, CSizeT), p_buf, bufsize.to_CSizeT]
    ).lift;
    if res == nullptr {
        throw("getcwd failed!: " + *get_last_error.lift)
    };
    pure $ buf.push_back(0_U8).from_bytes.as_ok
};

// `chdir(path)` changes the current working directory of the calling process to the specified directory.
//
// # Parameters
// - `dir_path`: a directory path
chdir: [m: MonadIOFail] Path -> m ();
chdir = |path| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let res = *path.borrow_c_str_io(|p_path|
        FFI_CALL_IO[CInt chdir(Ptr), p_path]
    ).lift;
    if res != 0.to_CInt {
        throw("chdir(\"" + path + "\") failed!: " + *get_last_error.lift)
    };
    pure()
};

//--------------------------------------------------------------------------
//  Files
//--------------------------------------------------------------------------

// Returns the canonicalized absolute pathname.
//
// For detials, see Linux manual page for [realpath(3)](https://man7.org/linux/man-pages/man3/realpath.3.html).
//
// # Parameters
// - `path`: a file or directory path, which may be a relative path
realpath: [m: MonadIOFail] String -> m String;
realpath = |path| lift_iofail $ do {
    pure();;    // make it lazy
    let p_resolved: Ptr = *path.borrow_c_str_io(|p_path|
        FFI_CALL_IO[Ptr realpath(Ptr, Ptr), p_path, nullptr]
    ).lift;
    if p_resolved == nullptr {
        throw("realpath(\"" + path + "\") failed!: " + *get_last_error.lift)
    };
    let resolved: String = String::unsafe_from_c_str_ptr(p_resolved);
    eval resolved;      // ensure `String::unsafe_from_c_str_ptr` is called before calling `free()`
    FFI_CALL_IO[() free(Ptr), p_resolved].lift;;
    pure $ resolved
};

// Creates a new file or rewrites an existing one.
//
// For details, see Linux manual page for [creat(3p)](https://man7.org/linux/man-pages/man3/creat.3p.html).
//
// # Parameters
// - `path`: a file path to be created
// - `mode`: a file mode of the created file
creat: [m: MonadIOFail] String -> U32 -> m CInt;
creat = |path, mode| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let fd = *path.borrow_c_str_io(|p_path|
        FFI_CALL_IO[CInt creat(Ptr, U32), p_path, mode]
    ).lift;
    if fd == -1.to_CInt {
        throw("creat(\"" + path + "\"," + mode.to_string + ") failed!: " + *get_last_error.lift)
    };
    pure $ fd
};

// Creates a symbolic link.
//
// For details, see Linux manual page for [symlink(2)](https://man7.org/linux/man-pages/man2/symlink.2.html).
//
// # Parameters
// - `target`: a file path the symolic link refers to
// - `link_path`: a path of the symbolic link
symlink: [m: MonadIOFail] String -> String -> m ();
symlink = |target, link_path| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let res = *target.borrow_c_str_io(|p_target|
        link_path.borrow_c_str_io(|p_link_path|
            FFI_CALL_IO[CInt symlink(Ptr, Ptr), p_target, p_link_path]
        )
    ).lift;
    if res == -1.to_CInt {
        throw("symlink(\"" + target + "\",\"" + link_path + "\") failed!: " + *get_last_error.lift)
    };
    pure()
};

// Deletes a name from the filesystem and possibly the file it refers to.
//
// For details, see Linux manual page for [unlink(2)](https://man7.org/linux/man-pages/man2/unlink.2.html).
//
// # Parameters
// - `path`: a file path to be deleted
unlink: [m: MonadIOFail] String -> m ();
unlink = |path| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let res = *path.borrow_c_str_io(|p_path|
        FFI_CALL_IO[CInt unlink(Ptr), p_path]
    ).lift;
    if res == -1.to_CInt {
        throw("unlink(\"" + path + "\") failed!: " + *get_last_error.lift)
    };
    pure()
};

// Deletes a name from the filesystem only if the name exists, and possibly the file it refers to.
//
// If the name points to a symbolic link, it deletes that symbolic link.
//
// For details, see Linux manual page for [unlink(2)](https://man7.org/linux/man-pages/man2/unlink.2.html).
//
// # Parameters
// - `path`: a path to be deleted
unlink_if_exists: [m: MonadIOFail] String -> m ();
unlink_if_exists = |path| lift_iofail $ do {
    let res = *lstat(path).to_result_t;
    when(res.is_ok, unlink(path))
};

// Associates a stream with a file descriptor.
//
// For details, see Linux manual page for [fdopen(3p)](https://man7.org/linux/man-pages/man3/fdopen.3p.html).
//
// # Parameters
// - `fd`: a file descriptor
// - `mode` a file open mode, such as "r", "w", "a" etc.
fdopen: [m: MonadIOFail] CInt -> String -> m IOHandle;
fdopen = |fd, mode| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let file_ptr = *mode.borrow_c_str_io(|p_mode|
        FFI_CALL_IO[Ptr fdopen(CInt, Ptr), fd, p_mode]
    ).lift;
    if file_ptr == nullptr {
        throw("fdopen(" + fd.to_string + ") failed!: " + *get_last_error.lift)
    };
    IOHandle::from_file_ptr(file_ptr).lift
};


// Creates a pipe. It returns `(read_fd, write_fd)` where `read_fd` is the file descriptor of
// read-end of the pipe, and `write_fd` is the file descriptor of write-end of the pipe.
//
// For details, see Linux manual page for [pipe(2)](https://man7.org/linux/man-pages/man2/pipe.2.html).
pipe: [m: MonadIOFail] m (CInt, CInt);
pipe = lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let pipefd: Array CInt = Array::fill(2, 0.to_CInt);
    let res = *pipefd.borrow_boxed_io(|p_pipefd|
        FFI_CALL_IO[CInt pipe(Ptr), p_pipefd]
    ).lift;
    if res == -1.to_CInt {
        throw("pipe failed!: " + *get_last_error.lift)
    };
    let read_fd = pipefd.@(0);
    let write_fd = pipefd.@(1);
    pure $ (read_fd, write_fd)
};

// Creates a pipe stream. It returns `(read_fh, write_fh)` where `read_fd` is the stream of
// read-end of the pipe, and `write_fd` is the stream of write-end of the pipe.
//
// For details, see Linux manual page for [pipe(2)](https://man7.org/linux/man-pages/man2/pipe.2.html).
open_pipe: [m: MonadIOFail] m (IOHandle, IOHandle);
open_pipe = lift_iofail $ do {
    pure();;    // make it lazy
    let (read_fd, write_fd) = *pipe;
    let read_fh = *fdopen(read_fd, "r");
    let write_fh = *fdopen(write_fd, "w");
    pure $ (read_fh, write_fh)
};

// Creates and opens a unique temporary file.
//
// Returns the file path and file handle of the created temporary file.
//
// The temporary file is opened in read/write mode.
//
// If `auto_unlink` is true, the temporary file is unlinked from the filesystem as soon as it is created and opened.
// If `auto_unlink` is false, the temporary file remains on the filesystem.
//
// The caller is responsible for performing any cleanup such as closing the file handle and deleting the temporary file.
//
// # Parameters
// - `filepath_prefix`: The file path prefix for the temporary file being created.
// - `auto_unlink`: If true, the temporary file will be unlinked from the file system as soon as it is created and opened.
open_temp_file: [m: MonadIOFail] String -> Bool -> m (String, IOHandle);
open_temp_file = |filepath_prefix, auto_unlink| lift_iofail $ do {
    let (filepath, fd) = *_open_temp_file(filepath_prefix);
    when(auto_unlink, unlink(filepath));;
    let handle = *fdopen(fd, "w+");
    pure $ (filepath, handle)
};

_open_temp_file: [m: MonadIOFail] String -> m (String, CInt);
_open_temp_file = |filepath_prefix| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let template_bytes = (filepath_prefix + "XXXXXX").get_bytes;
    let (filepath_bytes, fd) = *template_bytes.mutate_boxed_io(|p_template|
        FFI_CALL_IO[CInt mkstemp(Ptr), p_template]
    ).lift;
    if fd == -1.to_CInt {
        throw("mkstemp(\"" + filepath_prefix + "\") failed!: " + *get_last_error.lift)
    };
    let filepath = filepath_bytes.from_bytes.as_ok;
    pure $ (filepath, fd)
};

// Creates and opens a unique temporary file, performs `body`, then finally 
// performs a cleanup.
//
// The `body` is a function that takes a file path and a file handle as arguments and returns an IOFail monad.
// 
// The temporary file is opened in read/write mode. 
// 
// If `auto_unlink` is true, the temporary file is unlinked from the filesystem as soon as it is created and opened.
// If `auto_unlink` is false, the temporary file remains on the filesystem until the cleanup will be performed.
//
// On cleanup, the file handle will be closed, and the temporary file is unlinked if exists.
// 
// # Parameters
// - `filepath_prefix`: The file path prefix for the temporary file being created.
// - `auto_unlink`: If true, the temporary file will be unlinked from the file system as soon as it is created and opened.
// - `body`: A function that takes a file path and a file handle as arguments and returns an IOFail monad.
with_temp_file: [m: MonadIOFail] String -> Bool -> ((String, IOHandle) -> IOFail a) -> m a;
with_temp_file = |filepath_prefix, auto_unlink, body| lift_iofail $ do {
    let (filepath, handle) = *open_temp_file(filepath_prefix, auto_unlink);
    do {
        body((filepath, handle))
    }
    .finally(
        close_file(handle).lift;;
        unlink(filepath).when(*file_exists(filepath))
    )
};

// The type of file seek reference position
type SeekWhence = unbox union {
    // The start of the file
    seek_set: (),
    // The current position
    seek_cur: (),
    // The end of the file
    seek_end: ()
};

// Sets the file position of a file handle.
//
// # Parameters
// - `handle`: A file handle
// - `offset`: An offset relative to the reference position specified by `whence`
// - `whence`: The reference position
set_file_position: [m: MonadIOFail] IOHandle -> CLong -> SeekWhence -> m ();
set_file_position = |handle, offset, whence| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let whence = match whence {
        seek_set() => 0,
        seek_cur() => 1,
        seek_end() => 2,
    };
    let whence = FFI_CALL[CInt minilib_iofs_convert_seek_whence(CInt), whence.to_CInt];
    let file_ptr = *handle.get_file_ptr.lift;
    if file_ptr == nullptr {
        throw("seek_file_position failed!: the IOHandle is already closed.")
    };
    let res = *FFI_CALL_IO[CInt fseek(Ptr, CLong, CInt), file_ptr, offset, whence].lift;
    if res == -1.to_CInt {
        throw("fseek(" + file_ptr.to_string + "," + offset.to_string + "," + whence.to_string + ") failed!: " + *get_last_error.lift)
    };
    pure()
};

// Gets the file position of a file handle relative to the start of the file.
//
// # Parameters
// - `handle`: A file handle
get_file_position: [m: MonadIOFail] IOHandle -> m CLong;
get_file_position = |handle| lift_iofail $ do {
    pure();;    // make it lazy
    clear_errno.lift;;
    let file_ptr = *handle.get_file_ptr.lift;
    if file_ptr == nullptr {
        throw("get_file_position failed!: the IOHandle is already closed.")
    };
    let offset = *FFI_CALL_IO[CLong ftell(Ptr), file_ptr].lift;
    if offset == -1.to_CLong {
        throw("ftell(" + file_ptr.to_string + ") failed!: " + *get_last_error.lift)
    };
    pure $ offset
};